[user]
    email = Scott.Linder@amd.com
    name = Scott Linder
[color]
    ui = auto
[rebase]
    autoSquash = true
[sendemail]
    smtpEncryption = plain
    smtpServer = mail.gandi.net
    smtpUser = scott@scottlinder.com
    smtpServerPort = 587
[pull]
    ff = only
[commit]
    verbose = true
[core]
    pager = delta
[interactive]
    diffFilter = delta --color-only
    singleKey = true
[delta]
    navigate = true
    light = false
[merge]
    conflictstyle = diff3
[diff]
    colorMoved = default
[alias]
    ## [s]et...
    # [H]EAD
    sh = switch
    # HEAD [r]ef's head
    sr = reset
    # [f]ile contents
    sf = restore

    ## [v]iew...
    # [s]tatus
    vs = status
    # [d]iff
    vd = diff --no-prefix
    # [o]bject
    vo = show --no-prefix
    # [l]og
    vl = log --decorate --oneline
    # [l]og [v]erbose
    vlv = log --decorate
    # [l]og [g]raph
    vlg = log --decorate --oneline --graph --all

    ## [r]ebase...
    #
    r = rebase
    # [o]nto
    ro = rebase --onto
    # [r]ebase [a]utomatically based on HEAD ref following the convention <user>/<base>/<feature>
    ra = "!f() { branch=$(git rev-parse --abbrev-ref HEAD); base=\"$(printf '%s' \"$branch\" | sed 's#.*/\\(.*\\)/.*#\\1#')\"; git rebase \"$@\" \"$base\" \"$branch\"; }; f"
    # [p]ull base, then [r]ebase [a]utomatically based on HEAD ref following the convention <user>/<base>/<feature>
    pra = "!f() { branch=$(git rev-parse --abbrev-ref HEAD); base=\"$(printf '%s' \"$branch\" | sed 's#.*/\\(.*\\)/.*#\\1#')\"; git checkout \"$base\"; git pull; git rebase \"$@\" \"$base\" \"$branch\"; }; f"

    ## [c]ommit...
    #
    c = commit -vv
    # [a]mend
    ca = commit -vv --amend
    # [e]verything
    ce = "!f() { git add -A :/ && git commit -vv; }; f"
    # cherry [p]ick
    cp = cherry-pick

    # What patches are in a merge?
    show-merge = "!f() { git show --stat \"$1^..$1\"; }; f"
    # What merge brings in a specific commit?
    find-merge = "!sh -c 'commit=$0 && branch=${1:-HEAD} && (git rev-list $commit..$branch --ancestry-path | cat -n; git rev-list $commit..$branch --first-parent | cat -n) | sort -k2 -s | uniq -f1 -d | sort -n | tail -1 | cut -f2'"
    # Shortcut for deleting current branch and checking out the previous HEAD (git-branch doesn't support the `-` notation for `@{-1}`)
    done = "!f() { git checkout - && git branch -D @{-1}; }; f"

    # Push based on HEAD ref following the convention <user>/<base>/<feature>
    push-amd = "!f() { branch=$(git rev-parse --abbrev-ref HEAD); base=\"$(printf '%s' \"$branch\" | sed 's#.*/\\(.*\\)/.*#\\1#')\"; git push \"$@\" amd HEAD:refs/for/\"$base\"; }; f"
    # Push a debug info change
    push-dbg = push amd HEAD:refs/for/amd-stg-open%topic=SWDEV-171521,r=ttye,r=kzhuravl,r=vnalamot

    push-heterogeneous = "!f() { branch=${1:-HEAD}; remote=amd-gh; prefix=refs/heads/amd-feature/heterogeneous-dwarf/; next=$(git ls-remote --refs --heads $remote | gawk 'match($2, prefix \"(.*)\", groups) { if (groups[1] ~ /^[[:digit:]]+$/ && groups[1] > max) max = groups[1]; } END { printf \"%s%03d\\n\", prefix, max + 1; }' prefix=$prefix); git push $remote $branch:$next; git push -f $remote $branch:refs/tags/amd-feature/heterogeneous-dwarf/latest; }; f"
